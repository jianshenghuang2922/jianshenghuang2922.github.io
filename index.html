<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>魂斗罗 - 代号：赤色精英 </title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        body {
           
            
            color: white;
            font-family: 'Press Start 2P', cursive, sans-serif;
            margin: 0;
            overflow: hidden;
            touch-action: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        #game-container {
            position: relative;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
            border: 4px solid #4a5568;
        }

        canvas {
            display: block;
            background-color: #87CEEB;
            image-rendering: pixelated;
        }

        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.85);
            z-index: 10;
            text-align: center;
        }

        .hidden { display: none !important; }

        .btn {
            background: #e53e3e;
            border: 4px solid white;
            color: white;
            padding: 15px 30px;
            font-family: inherit;
            font-size: 16px;
            cursor: pointer;
            margin: 10px;
            text-transform: uppercase;
            transition: transform 0.1s;
        }
        
        .btn:active { transform: scale(0.95); }
        .btn-secondary { background: #4a5568; }

        /* 移动端控制 */
        #controls {
            display: none;
            width: 100%;
            max-width: 800px;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
            position: absolute;
            bottom: 10px;
            z-index: 20;
        }

        .d-pad {
            position: relative;
            width: 120px;
            height: 120px;
        }

        .d-btn {
            position: absolute;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            width: 40px;
            height: 40px;
        }
        .d-up { top: 0; left: 40px; } 
        .d-down { bottom: 0; left: 40px; }
        .d-left { top: 40px; left: 0; }
        .d-right { top: 40px; right: 0; }
        .d-btn:active { background: rgba(255, 255, 255, 0.5); }

        .action-btns {
            display: flex;
            gap: 20px;
            align-items: flex-end;
        }

        .a-btn, .b-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            user-select: none;
        }
        .a-btn { background: rgba(229, 62, 62, 0.5); }
        .b-btn { background: rgba(66, 153, 225, 0.5); }
        .a-btn:active, .b-btn:active { transform: scale(0.9); opacity: 0.8; }

        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            text-shadow: 2px 2px 0 #000;
            z-index: 5;
            font-size: 14px;
            display: flex;
            gap: 20px;
        }
        
        #boss-hp-bar {
            width: 100px;
            height: 10px;
            background: #333;
            border: 1px solid white;
            display: inline-block;
            margin-left: 5px;
        }
        #boss-hp-fill {
            height: 100%;
            background: #e53e3e;
            width: 100%;
            transition: width 0.2s;
        }

        @media (max-width: 800px) {
            #controls { display: flex; }
            #instructions { display: none; }
        }
    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="gameCanvas" width="800" height="450"></canvas>

        <div id="hud" class="hidden">
            <div>玩家: <span id="scoreVal">0</span></div>
            <div>关卡: <span id="levelVal">1</span></div>
            <div id="boss-hp-container" class="hidden">
                BOSS: <div id="boss-hp-bar"><div id="boss-hp-fill"></div></div>
            </div>
        </div>

        <!-- 启动屏幕 -->
        <div id="start-screen" class="overlay">
            <h1 class="text-4xl text-yellow-400 mb-4 tracking-widest" style="text-shadow: 4px 4px 0 #e53e3e;">魂斗罗</h1>
            <h2 class="text-xl text-white mb-8">行动代号：幽灵协议</h2>
            <button class="btn" onclick="startGame()">开始任务</button>
            <div id="instructions" class="mt-8 text-xs text-gray-300">
                <p>控制: <br>左右方向键移动</p>
                <p>上方向键 (ArrowUp): 跳跃 (支持二段跳)</p>
                <p>Z: 射击<br> R: 重新挑战</p>
            </div>
        </div>

        <!-- 游戏结束屏幕 -->
        <div id="game-over-screen" class="overlay hidden">
            <h1 class="text-4xl text-red-600 mb-4">任务失败</h1>
            <p class="mb-8 text-gray-300">虽然只有一条命，但战士永不言弃。</p>
            <div class="flex flex-col gap-4">
                <button class="btn" onclick="retryLevel()">重新挑战</button>
                <button class="btn btn-secondary" onclick="quitGame()">放弃</button>
            </div>
        </div>

        <!-- 关卡过渡 -->
        <div id="level-screen" class="overlay hidden">
            <h1 class="text-3xl text-white mb-2" id="level-title">第 1 关</h1>
            <p class="text-green-400" id="level-sub">丛林突围</p>
        </div>

        <!-- 胜利屏幕 -->
        <div id="victory-screen" class="overlay hidden">
            <h1 class="text-4xl text-yellow-400 mb-4">全任务完成!</h1>
            <p class="mb-8 text-white">幽灵王已被消灭。</p>
            <p class="mb-8 text-blue-300">最终得分: <span id="finalScore">0</span></p>
            <button class="btn" onclick="quitGame()">返回主菜单</button>
        </div>
    </div>

    <!-- 移动端控件 -->
    <div id="controls">
        <div class="d-pad">
            <div class="d-btn d-down" data-key="ArrowDown"></div>
            <div class="d-btn d-left" data-key="ArrowLeft"></div>
            <div class="d-btn d-right" data-key="ArrowRight"></div>
        </div>
        <div class="action-btns">
            <div class="a-btn" data-key="KeyZ">射击</div>
            <!-- 手机端B键绑定跳跃逻辑 -->
            <div class="b-btn" id="mobile-jump-btn">跳跃</div>
        </div>
    </div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// 游戏常量 (保持原值)
const GRAVITY = 0.25; 
const TERMINAL_VELOCITY = 10;
const PLAYER_SPEED = 3;
const JUMP_FORCE = -7.5; 
const BULLET_SPEED = 8;
const ENEMY_SPEED = 1.5;

// 输入状态
const keys = {
    ArrowDown: false,
    ArrowLeft: false,
    ArrowRight: false,
    KeyZ: false,
    KeyR: false,
    ArrowUp: false // 保留 ArrowUp 状态用于其他检测，但跳跃触发使用 KeyDown 事件
};

// 游戏状态
let gameState = 'MENU';
let currentLevel = 1;
let score = 0;
let cameraX = 0;
let frameCount = 0;
let particles = [];
let bullets = [];
let enemies = [];
let platforms = [];
let boss = null;
let levelWidth = 3000;

// 玩家对象
    // JavaScript source code
    const player = {
        x: 50,
        y: 100,
        width: 24,
        height: 48,
        vx: 0,
        vy: 0,
        jumpCount: 2, // 二段跳计数
        facingRight: true,
        isGrounded: false,
        isDead: false,
        shootCooldown: 0,
        color: '#3182ce',
        skinColor: '#f6e05e',
        headBandColor: '#e53e3e'
    };

    // --- 输入处理优化 ---
    window.addEventListener('keydown', (e) => {
        // 修复二段跳：在按下瞬间触发，而不是在update里持续触发
        if (e.code === 'ArrowUp') {
            tryJump();
        }
        if (keys.hasOwnProperty(e.code)) keys[e.code] = true;
    });

    window.addEventListener('keyup', (e) => {
        if (keys.hasOwnProperty(e.code)) keys[e.code] = false;
    });

    // 触摸处理 - 方向键和射击
    const touchBtns = document.querySelectorAll('#controls div[data-key]');
    touchBtns.forEach(btn => {
        const code = btn.dataset.key;
        btn.addEventListener('touchstart', (e) => { e.preventDefault(); keys[code] = true; });
        btn.addEventListener('touchend', (e) => { e.preventDefault(); keys[code] = false; });
    });

    // 触摸处理 - 跳跃独立绑定
    const mobileJumpBtn = document.getElementById('mobile-jump-btn');
    mobileJumpBtn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        tryJump();
        keys['ArrowUp'] = true; // 模拟按键状态
    });
    mobileJumpBtn.addEventListener('touchend', (e) => {
        e.preventDefault();
        keys['ArrowUp'] = false;
    });

    function tryJump() {
        if (gameState !== 'PLAYING' || player.isDead) return;

        // 如果还有跳跃次数
        if (player.jumpCount > 0) {
            player.vy = JUMP_FORCE;
            player.jumpCount--;
            player.isGrounded = false;
            // 粒子特效
            createParticles(player.x + player.width / 2, player.y + player.height, '#fff', 5);
        }
    }

// --- 游戏类定义 ---

class Bullet {
    constructor(x, y, vx, vy, isPlayerBullet) {
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        // 增加玩家子弹的判定体积，修复打不到怪的问题
        this.width = isPlayerBullet ? 12 : 6; 
        this.height = isPlayerBullet ? 12 : 6;
        this.isPlayerBullet = isPlayerBullet;
        this.active = true;
        this.color = isPlayerBullet ? '#fbd38d' : '#e53e3e';
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;
        if (this.x < cameraX || this.x > cameraX + canvas.width || this.y < 0 || this.y > canvas.height) {
            this.active = false;
        }
    }

    draw() {
        ctx.fillStyle = this.color;
        ctx.beginPath();
        // 绘制圆形视觉效果，但逻辑碰撞用矩形
        ctx.arc(this.x - cameraX + this.width/2, this.y + this.height/2, this.width/2, 0, Math.PI * 2);
        ctx.fill();
    }
}

class Enemy {
    constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.width = 30;
        this.height = 40;
        this.type = type;
        this.vx = type === 'turret' ? 0 : -ENEMY_SPEED;
        this.vy = 0;
        this.hp = 1;
        this.active = true;
        this.shootTimer = Math.random() * 100;
        this.isGrounded = false;
    }

    update() {
        if (this.x > cameraX + canvas.width + 100 || this.x < cameraX - 100) return;

        this.vy += GRAVITY;
        this.y += this.vy;
        
        // 简单的地面碰撞
        this.isGrounded = false;
        for (let p of platforms) {
            if (rectIntersect(
                {x: this.x, y: this.y + this.vy, width: this.width, height: this.height}, // 预测下一帧位置
                p
            ) && this.vy >= 0) {
                 // 稍微简化的着陆判断
                 if (this.y + this.height <= p.y + 15) {
                    this.y = p.y - this.height;
                    this.vy = 0;
                    this.isGrounded = true;
                 }
            }
        }

        if (this.type === 'runner') {
            if (this.isGrounded) this.x += this.vx;
            if (this.x < cameraX && this.vx < 0) this.vx *= -1;
        } else if (this.type === 'shooter') {
            if (this.shootTimer <= 0) {
                let dx = player.x - this.x;
                let dir = dx > 0 ? 1 : -1;
                bullets.push(new Bullet(this.x + this.width/2, this.y + 10, dir * 4, 0, false));
                this.shootTimer = 120;
            }
        } else if (this.type === 'turret') {
            if (this.shootTimer <= 0 && this.x < cameraX + canvas.width) {
                 let angle = Math.atan2((player.y - this.y), (player.x - this.x));
                 bullets.push(new Bullet(this.x + this.width/2, this.y + 10, Math.cos(angle)*4, Math.sin(angle)*4, false));
                 this.shootTimer = 150;
            }
        }

        if (this.shootTimer > 0) this.shootTimer--;
    }

    draw() {
        if (this.x > cameraX + canvas.width + 50 || this.x < cameraX - 50) return;
        const screenX = this.x - cameraX;
        ctx.fillStyle = this.type === 'turret' ? '#718096' : '#2d3748';
        ctx.fillRect(screenX, this.y, this.width, this.height);
        ctx.fillStyle = 'red';
        if (this.type === 'turret') ctx.fillRect(screenX + 4, this.y + 4, 22, 10);
        else ctx.fillRect(screenX + (this.vx > 0 ? 20 : 2), this.y + 6, 8, 4);
    }
}

class Boss {
    constructor(x, y, level) {
        this.x = x;
        this.y = y;
        this.level = level;
        this.active = true;
        this.timer = 0;
        this.isInvulnerable = false; // 默认无敌状态标志
        this.alpha = 1.0; 
        
        if (level === 1) {
            this.width = 120;
            this.height = 160;
            this.maxHp = 40;
            this.guns = [{x: 10, y: 30}, {x: 10, y: 120}];
        } else if(level === 2) {
            this.width = 80;
            this.height = 80;
            this.maxHp = 30;
            this.vx = 2;
            this.vy = 2;
        } else if(level === 3) {
            // 第3关：雪地要塞 - 防御机制
            this.width = 100;
            this.height = 100;
            this.maxHp = 50;
            this.vx = 3;
            this.vy = 1;
            this.isInvulnerable = true; // 初始无敌
        } else if(level === 4) {
            // 第4关：幽灵王
            this.width = 90;
            this.height = 110;
            this.maxHp = 20;
            this.isInvulnerable = true; // 初始隐身无敌
            this.alpha = 0;
            this.state = 'hiding';
        }
        this.hp = this.maxHp;
    }

    update() {
        if (!this.active || this.x > cameraX + canvas.width) return;

        // UI
        document.getElementById('boss-hp-container').classList.remove('hidden');
        document.getElementById('boss-hp-fill').style.width = (this.hp / this.maxHp * 100) + '%';

        // --- 关卡 1 ---
        if (this.level === 1) {
            this.timer++;
            if (this.timer > 80) {
                let gun = this.guns[Math.floor(Math.random() * this.guns.length)];
                let angle = Math.atan2(player.y - (this.y + gun.y), player.x - (this.x + gun.x));
                bullets.push(new Bullet(this.x + gun.x, this.y + gun.y, Math.cos(angle)*5, Math.sin(angle)*5, false));
                this.timer = 0;
            }
        } 
        // --- 关卡 2 ---
        else if (this.level === 2) {
            this.x += this.vx;
            this.y += this.vy;
            if (this.x < cameraX + 400 || this.x > cameraX + 700) this.vx *= -1;
            if (this.y < 50 || this.y > 300) this.vy *= -1;
            
            if (++this.timer > 100) {
                 bullets.push(new Bullet(this.x+40, this.y+40, -4, 0, false));
                 bullets.push(new Bullet(this.x+40, this.y+40, -4, 2, false));
                 bullets.push(new Bullet(this.x+40, this.y+40, -4, -2, false));
                 this.timer = 0;
            }
        }
        // --- 关卡 3 (机制修改) ---
        else if (this.level === 3) {
            this.x += this.vx;
            if (this.x < cameraX + 350 || this.x > cameraX + 650) this.vx *= -1;
            this.y = this.y + Math.sin(frameCount * 0.05) * 2;

            this.timer++;
            // 0-150: 蓄力（无敌）
            // 150-250: 攻击（取消无敌）
            if (this.timer < 150) {
                this.isInvulnerable = true;
            } else if (this.timer >= 150 && this.timer < 250) {
                this.isInvulnerable = false;
                if (this.timer % 20 === 0) {
                    let angle = Math.atan2(player.y - (this.y+50), player.x - (this.x+50));
                    bullets.push(new Bullet(this.x+50, this.y+50, Math.cos(angle)*6, Math.sin(angle)*6, false));
                }
            } else {
                this.timer = 0;
            }
        }
        // --- 关卡 4 (幽灵王) ---
        else if (this.level === 4) {
            this.timer++;
            // 飘向玩家
            let dx = (player.x + 300) - this.x;
            this.x += dx * 0.01; 
            
            if (this.timer < 120) {
                // 隐身移动
                this.state = 'hiding';
                this.isInvulnerable = true;
                if(this.alpha > 0) this.alpha -= 0.02;
            } else if (this.timer < 180) {
                // 显形
                this.state = 'appearing';
                this.isInvulnerable = true;
                if(this.alpha < 1) this.alpha += 0.05;
            } else if (this.timer < 300) {
                // 攻击
                this.state = 'attacking';
                this.alpha = 1;
                this.isInvulnerable = false; // 取消无敌，可以被打
                
                if (this.timer % 30 === 0) {
                     bullets.push(new Bullet(this.x + 45, this.y + 55, -5, (Math.random()-0.5)*3, false));
                }
            } else {
                // 循环
                this.timer = 0;
                // 随机瞬移位置
                this.y = 50 + Math.random() * 200;
                this.x = cameraX + 400 + Math.random() * 300;
            }
        }

        // BOSS 碰撞
        bullets.forEach(b => {
            if (b.isPlayerBullet && b.active) {
                if (rectIntersect(b, this)) {
                    b.active = false;
                    
                    if (this.isInvulnerable) {
                        // 无敌状态：打铁声
                        createParticles(b.x, b.y, '#ccc', 2);
                    } else {
                        // 受伤
                        this.hp--;
                        createParticles(b.x, b.y, '#fff', 4);
                        if (this.hp <= 0) {
                            this.active = false;
                            createParticles(this.x + this.width/2, this.y + this.height/2, '#f00', 100);
                            score += 2000;
                            setTimeout(victoryLevel, 1500);
                        }
                    }
                }
            }
        });
    }

    draw() {
        if (!this.active) return;
        let screenX = this.x - cameraX;
        
        ctx.save();
        
        if (this.level === 1) {
            ctx.fillStyle = '#742a2a';
            ctx.fillRect(screenX, this.y, this.width, this.height);
            // 核心
            ctx.fillStyle = '#4fd1c5';
            if (frameCount % 20 < 10) ctx.fillRect(screenX + 40, this.y + 60, 40, 40);
        } else if (this.level === 2) {
            ctx.fillStyle = '#6b46c1';
            ctx.beginPath();
            ctx.ellipse(screenX + 40, this.y + 40, 40, 30, 0, 0, Math.PI*2);
            ctx.fill();
        } else if (this.level === 3) {
            // 雪地要塞
            if (this.isInvulnerable) {
                // 护盾
                ctx.strokeStyle = '#63b3ed';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(screenX + 50, this.y + 50, 65, 0, Math.PI*2);
                ctx.stroke();
                ctx.fillStyle = '#2c7a7b';
            } else {
                ctx.fillStyle = '#e53e3e'; // 变红表示可攻击
            }
            ctx.fillRect(screenX, this.y, this.width, this.height);
        } else if (this.level === 4) {
            // 幽灵王
            ctx.globalAlpha = this.alpha;
            ctx.fillStyle = this.isInvulnerable ? '#718096' : '#9f7aea';
            
            // 画个幽灵形状
            ctx.beginPath();
            ctx.arc(screenX + 45, this.y + 40, 40, Math.PI, 0);
            ctx.lineTo(screenX + 85, this.y + 100);
            ctx.lineTo(screenX + 45, this.y + 90);
            ctx.lineTo(screenX + 5, this.y + 100);
            ctx.fill();
            
            // 眼睛
            if (this.alpha > 0.5) {
                ctx.fillStyle = 'red';
                ctx.beginPath();
                ctx.arc(screenX + 30, this.y + 40, 5, 0, Math.PI*2);
                ctx.arc(screenX + 60, this.y + 40, 5, 0, Math.PI*2);
                ctx.fill();
            }
        }
        
        ctx.restore();
    }
}

// 辅助：矩形碰撞检测 (修复子弹打不到怪的核心)
function rectIntersect(r1, r2) {
    return !(r2.x > r1.x + r1.width || 
             r2.x + r2.width < r1.x || 
             r2.y > r1.y + r1.height || 
             r2.y + r2.height < r1.y);
}

class Particle {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.vx = (Math.random() - 0.5) * 8;
        this.vy = (Math.random() - 0.5) * 8;
        this.life = 20 + Math.random() * 20;
        this.color = color;
    }
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life--;
    }
    draw() {
        ctx.globalAlpha = Math.max(0, this.life / 40);
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x - cameraX, this.y, 4, 4);
        ctx.globalAlpha = 1;
    }
}

function createParticles(x, y, color, count) {
    for(let i=0; i<count; i++) {
        particles.push(new Particle(x, y, color));
    }
}

// --- 关卡构建 ---
function initLevel(level) {
    currentLevel = level;
    document.getElementById('levelVal').innerText = level;
    document.getElementById('boss-hp-container').classList.add('hidden');
    
    bullets = [];
    particles = [];
    enemies = [];
    platforms = [];
    cameraX = 0;
    
    player.x = 50;
    player.y = 100;
    player.vx = 0;
    player.vy = 0;
    player.jumpCount = 2; // 重置二段跳
    player.isDead = false;

    // 通用底板
    platforms.push({x: -100, y: 400, width: 4000, height: 100});

    if (level === 1) {
        levelWidth = 2000;
        platforms.push({x: 300, y: 300, width: 100, height: 20});
        platforms.push({x: 500, y: 220, width: 100, height: 20});
        platforms.push({x: 700, y: 300, width: 100, height: 20});
        platforms.push({x: 900, y: 200, width: 300, height: 20});
        
        enemies.push(new Enemy(800, 100, 'runner'));
        enemies.push(new Enemy(1100, 100, 'shooter'));
        enemies.push(new Enemy(1400, 300, 'turret'));
        
        boss = new Boss(1800, 240, 1);
    } 
    else if (level === 2) {
        levelWidth = 2000;
        platforms.push({x: 400, y: 300, width: 100, height: 20});
        platforms.push({x: 600, y: 200, width: 100, height: 20});
        platforms.push({x: 900, y: 350, width: 200, height: 20});
        
        enemies.push(new Enemy(500, 100, 'shooter'));
        enemies.push(new Enemy(950, 200, 'runner'));
        
        boss = new Boss(1700, 100, 2);
    }
    else if (level === 3) {
        levelWidth = 2000;
        platforms.push({x: 300, y: 300, width: 150, height: 20});
        platforms.push({x: 500, y: 200, width: 150, height: 20});
        platforms.push({x: 800, y: 300, width: 150, height: 20});
        platforms.push({x: 1100, y: 200, width: 150, height: 20});

        enemies.push(new Enemy(400, 100, 'shooter'));
        enemies.push(new Enemy(850, 100, 'turret'));
        enemies.push(new Enemy(1200, 100, 'shooter'));
        
        boss = new Boss(1600, 150, 3);
    }
    else if (level === 4) {
        // 幽灵王关卡
        levelWidth = 1500;
        platforms.push({x: 200, y: 320, width: 100, height: 20});
        platforms.push({x: 400, y: 240, width: 100, height: 20});
        platforms.push({x: 600, y: 160, width: 100, height: 20});
        platforms.push({x: 800, y: 240, width: 100, height: 20});
        
        enemies.push(new Enemy(500, 50, 'runner'));
        boss = new Boss(1000, 100, 4);
    }
}

function update() {
    if (gameState !== 'PLAYING') return;
    frameCount++;

    // 玩家左右移动
    if (keys.ArrowRight) player.vx = PLAYER_SPEED;
    else if (keys.ArrowLeft) player.vx = -PLAYER_SPEED;
    else player.vx = 0;

    if (player.vx > 0) player.facingRight = true;
    if (player.vx < 0) player.facingRight = false;

    // 射击
    if (keys.KeyZ && player.shootCooldown <= 0) {
        let bx = player.x + (player.facingRight ? player.width : 0);
        let by = player.y + 12;
        let bvx = player.facingRight ? BULLET_SPEED : -BULLET_SPEED;
        
        bullets.push(new Bullet(bx, by, bvx, 0, true));
        player.shootCooldown = 12;
    }
    if (player.shootCooldown > 0) player.shootCooldown--;

    // 物理
    player.vy += GRAVITY;
    if (player.vy > TERMINAL_VELOCITY) player.vy = TERMINAL_VELOCITY;
    player.x += player.vx;
    player.y += player.vy;

    // 边界与掉落
    player.isGrounded = false;
    if (player.x < cameraX) player.x = cameraX;
    if (player.x > levelWidth) player.x = levelWidth;
    if (player.y > canvas.height + 50) die();

    // 平台碰撞 (重置二段跳)
    platforms.forEach(p => {
        // 使用 rectIntersect 进行更精确的判断
        if (player.vx === 0) {
            // 静止时的简单AABB
             if (rectIntersect(player, p) && player.vy >= 0 && player.y + player.height - player.vy <= p.y + 10) {
                 landOnPlatform(p);
             }
        } else {
            // 移动时的碰撞预测
            if (player.x + player.width > p.x && player.x < p.x + p.width &&
                player.y + player.height > p.y && player.y + player.height < p.y + p.height + 15 &&
                player.vy >= 0) {
                    if (player.y + player.height - player.vy <= p.y + 10) {
                        landOnPlatform(p);
                    }
            }
        }
    });

    function landOnPlatform(p) {
        player.y = p.y - player.height;
        player.vy = 0;
        player.isGrounded = true;
        player.jumpCount = 2; // 落地，重置二段跳
    }

    // 相机
    let targetCameraX = player.x - 200;
    if (targetCameraX < 0) targetCameraX = 0;
    if (targetCameraX > levelWidth - canvas.width) targetCameraX = levelWidth - canvas.width;
    if (targetCameraX > cameraX) cameraX += (targetCameraX - cameraX) * 0.1;

    // 更新实体
    bullets.forEach(b => b.update());
    enemies.forEach(e => e.update());
    particles.forEach(p => p.update());
    if (boss) boss.update();

    bullets = bullets.filter(b => b.active);
    enemies = enemies.filter(e => e.hp > 0);
    particles = particles.filter(p => p.life > 0);

    // 碰撞检测：玩家子弹击中敌人 (使用新修复的碰撞检测)
    bullets.forEach(b => {
        if (b.isPlayerBullet && b.active) {
            enemies.forEach(e => {
                if (rectIntersect(b, e)) {
                    b.active = false;
                    e.hp--;
                    createParticles(e.x + e.width/2, e.y + e.height/2, '#fff', 5);
                    if (e.hp <= 0) {
                        score += 100;
                        createParticles(e.x + e.width/2, e.y + e.height/2, '#f00', 10);
                    }
                }
            });
        }
    });

    // 玩家受伤检测
    if (!player.isDead) {
        bullets.forEach(b => {
            if (!b.isPlayerBullet && b.active) {
                if (rectIntersect(player, b)) die();
            }
        });
        enemies.forEach(e => {
            if (rectIntersect(player, e)) die();
        });
        if (boss && boss.active && rectIntersect(player, boss)) die();
    }
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // 背景
    const bgColors = ['#2c5282', '#1a202c', '#e2e8f0', '#000000'];
    ctx.fillStyle = bgColors[currentLevel - 1] || '#000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // 平台
    ctx.fillStyle = currentLevel === 3 ? '#a0aec0' : '#4a5568';
    if(currentLevel === 4) ctx.fillStyle = '#2d3748';

    platforms.forEach(p => {
        if (p.x - cameraX + p.width > 0 && p.x - cameraX < canvas.width) {
            ctx.fillRect(p.x - cameraX, p.y, p.width, p.height);
            ctx.strokeStyle = '#fff';
            ctx.strokeRect(p.x - cameraX, p.y, p.width, p.height);
        }
    });

    if (boss) boss.draw();
    enemies.forEach(e => e.draw());

    if (!player.isDead) {
        let screenX = player.x - cameraX;
        ctx.fillStyle = player.skinColor;
        ctx.fillRect(screenX, player.y, player.width, 12); 
        ctx.fillStyle = player.color;
        ctx.fillRect(screenX, player.y + 24, player.width, 24);
        ctx.fillStyle = player.skinColor;
        ctx.fillRect(screenX, player.y + 12, player.width, 12);
        
        ctx.fillStyle = player.headBandColor;
        ctx.fillRect(screenX, player.y + 4, player.width, 4);
        
        ctx.fillStyle = '#1a202c';
        if (player.facingRight) ctx.fillRect(screenX + 10, player.y + 18, 24, 6);
        else ctx.fillRect(screenX - 10, player.y + 18, 24, 6);
    }

    bullets.forEach(b => b.draw());
    particles.forEach(p => p.draw());

    document.getElementById('scoreVal').innerText = score;
}

function gameLoop() {
    update();
    draw();
    requestAnimationFrame(gameLoop);
    if (keys.KeyR && (gameState === 'GAMEOVER' || gameState === 'PLAYING')) {
        retryLevel();
    }
}

// 流程控制
function startGame() {
    document.getElementById('start-screen').classList.add('hidden');
    document.getElementById('hud').classList.remove('hidden');
    if('ontouchstart' in window || navigator.maxTouchPoints > 0) {
        document.getElementById('controls').style.display = 'flex';
    }
    startLevel(1);
    gameState = 'PLAYING';
    gameLoop();
}

function startLevel(lvl) {
    gameState = 'LEVEL_TRANSITION';
    let title = `第 ${lvl} 关`;
    let sub = ['丛林突围', '异形基地', '雪地要塞', '幽灵王座'][lvl-1];
   
    document.getElementById('level-title').innerText = title;
    document.getElementById('level-sub').innerText = sub;
    document.getElementById('level-screen').classList.remove('hidden');

    setTimeout(() => {
        document.getElementById('level-screen').classList.add('hidden');
        initLevel(lvl);
        gameState = 'PLAYING';
    }, 2000);
}

function die() {
    if (player.isDead) return;
    player.isDead = true;
    createParticles(player.x, player.y, '#e53e3e', 30);
    setTimeout(() => {
        gameState = 'GAMEOVER';
        document.getElementById('game-over-screen').classList.remove('hidden');
    }, 1000);
}

function retryLevel() {
    document.getElementById('game-over-screen').classList.add('hidden');
    initLevel(currentLevel);
    gameState = 'PLAYING';
}

function quitGame() {
    location.reload();
}

function victoryLevel() {
    if (currentLevel < 4) {
        startLevel(currentLevel + 1);
    } else {
        gameState = 'VICTORY';
        document.getElementById('finalScore').innerText = score;
        document.getElementById('victory-screen').classList.remove('hidden');
    }
}
</script>
</body>

</html>
